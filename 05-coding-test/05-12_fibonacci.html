<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>피보나치 수열(Fibonacci Sequence)</title>
  </head>
  <body>
    <script>
      // 피보나치 수열은 첫째 및 둘째 항이 1이며, 그 뒤의 모든 항은 바로 앞 두 항의 합으로 이루어지는 수열입니다.
      // (단, 0번째 항을 0으로 두는 경우도 많습니다. 여기서는 0번째=0, 1번째=1로 시작하겠습니다.)
      // 예: 0, 1, 1, 2, 3, 5, 8, 13, 21, ...

      // --- 1. 반복문(for loop)을 이용한 구현 (가장 효율적) ---
      // 동적 계획법(Dynamic Programming)의 가장 기본적인 형태로, 계산한 값을 저장해나가며 진행합니다.
      console.log("--- 1. 반복문 방식 (가장 효율적) ---");

      function fibonacci_iterative(n) {
        if (n < 0) return "잘못된 입력입니다.";
        if (n <= 1) return n;

        let prev = 0; // F(n-2)
        let current = 1; // F(n-1)
        let result = 0;

        for (let i = 2; i <= n; i++) {
          result = prev + current; // F(n) = F(n-2) + F(n-1)
          prev = current;
          current = result;
        }
        return result;
      }

      console.log("10번째 피보나치 수:", fibonacci_iterative(10)); // 55
      console.log("40번째 피보나치 수:", fibonacci_iterative(40)); // 102334155

      // --- 2. 단순 재귀를 이용한 구현 (가장 비효율적) ---
      // 수학적 정의를 그대로 코드로 옮겨 직관적이지만, 동일한 계산을 수없이 반복하여 매우 비효율적입니다.
      // n이 40 정도만 되어도 브라우저가 멈출 수 있습니다. (시간 복잡도: O(2^n))
      console.log("\n--- 2. 단순 재귀 방식 (매우 비효율적) ---");

      function fibonacci_recursive(n) {
        if (n < 0) return "잘못된 입력입니다.";
        // 재귀의 탈출 조건 (Base Case)
        if (n <= 1) return n;

        // fib(5)를 구하기 위해 fib(4)와 fib(3)을 호출하고,
        // fib(4)를 구하기 위해 또 fib(3)과 fib(2)를 호출하는 등 중복 계산이 발생
        return fibonacci_recursive(n - 1) + fibonacci_recursive(n - 2);
      }

      console.log("10번째 피보나치 수:", fibonacci_recursive(10)); // 55
      // console.log('40번째 피보나치 수:', fibonacci_recursive(40)); // 실행 시간이 매우 오래 걸림

      // --- 3. 재귀와 메모이제이션(Memoization)을 이용한 최적화 ---
      // 한 번 계산한 결과를 저장(캐싱)해두고, 다음번에 동일한 계산이 필요할 때 저장된 값을 바로 반환하는 기법입니다.
      // 재귀의 간결함과 반복문의 효율성을 모두 가질 수 있습니다. (시간 복잡도: O(n))
      console.log("\n--- 3. 메모이제이션을 사용한 재귀 방식 (효율적) ---");

      function fibonacci_memoization(n, memo = {}) {
        if (n < 0) return "잘못된 입력입니다.";
        // 이미 계산된 값이 메모(memo)에 있으면 바로 반환
        if (n in memo) return memo[n];
        if (n <= 1) return n;

        // 계산되지 않은 값이면 재귀 호출로 계산하고, 그 결과를 메모에 저장
        memo[n] =
          fibonacci_memoization(n - 1, memo) +
          fibonacci_memoization(n - 2, memo);
        return memo[n];
      }

      console.log("10번째 피보나치 수:", fibonacci_memoization(10)); // 55
      console.log("40번째 피보나치 수:", fibonacci_memoization(40)); // 102334155 (빠르게 계산됨)
    </script>
  </body>
</html>
