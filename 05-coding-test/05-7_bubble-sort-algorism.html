<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>정렬 알고리즘: 버블 정렬(Bubble Sort)</title>
  </head>
  <body>
    <script>
      // 버블 정렬(Bubble Sort)은 인접한 두 요소를 비교하여,
      // 정렬 순서에 맞지 않으면 위치를 교환하는 방식으로 동작하는 가장 간단한 정렬 알고리즘입니다.
      // 매 회차(pass)마다 가장 큰 요소가 배열의 맨 끝으로 "거품(bubble)"처럼 올라가는 것처럼 보입니다.
      // 시간 복잡도: O(n^2) - 비효율적이므로 학습용으로 주로 사용됩니다.

      // --- 1. 기본 버블 정렬 구현 ---
      console.log("--- 1. 기본 버블 정렬 ---");
      function bubbleSort(arr) {
        const n = arr.length;
        // 총 n-1 회의 pass를 진행
        for (let i = 0; i < n - 1; i++) {
          // 각 pass마다 인접한 요소를 비교
          // (i가 증가할수록 배열의 끝부분은 정렬이 완료되므로, 비교 범위를 줄임)
          for (let j = 0; j < n - 1 - i; j++) {
            // 현재 요소가 다음 요소보다 크면 위치를 교환
            if (arr[j] > arr[j + 1]) {
              // ES6 Destructuring assignment을 이용한 swap
              [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
            }
          }
        }
        return arr;
      }

      const unsortedArray1 = [5, 3, 8, 4, 2];
      console.log("정렬 전:", unsortedArray1);
      // 원본 배열 유지를 위해 복사본을 만들어 정렬 함수에 전달합니다.
      const sortedArray1 = bubbleSort([...unsortedArray1]);
      console.log("정렬 후:", sortedArray1);

      // --- 2. 최적화된 버블 정렬 구현 ---
      // 어떤 pass에서 요소 교환이 한 번도 일어나지 않았다면,
      // 그 시점에서 배열은 이미 정렬된 상태이므로, 정렬을 조기 종료할 수 있습니다.
      console.log("\n--- 2. 최적화된 버블 정렬 ---");
      function optimizedBubbleSort(arr) {
        const n = arr.length;
        for (let i = 0; i < n - 1; i++) {
          let swapped = false; // 이번 pass에서 교환이 일어났는지 체크하는 플래그
          for (let j = 0; j < n - 1 - i; j++) {
            if (arr[j] > arr[j + 1]) {
              [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
              swapped = true;
            }
          }
          // 만약 이번 pass에서 교환이 한 번도 없었다면, 정렬이 완료된 것이므로 종료
          if (!swapped) {
            console.log(`(정렬이 ${i + 1}번째 pass에서 조기 종료되었습니다.)`);
            break;
          }
        }
        return arr;
      }

      const unsortedArray2 = [1, 2, 4, 3, 5]; // 거의 정렬된 배열
      console.log("정렬 전:", unsortedArray2);
      const sortedArray2 = optimizedBubbleSort([...unsortedArray2]);
      console.log("정렬 후:", sortedArray2);

      // --- 3. 정렬 과정 시각화 ---
      console.log("\n--- 3. 정렬 과정 시각화 ---");
      function visualBubbleSort(arr) {
        const n = arr.length;
        console.log("초기 상태:", `[${arr.join(", ")}]`);
        for (let i = 0; i < n - 1; i++) {
          console.log(`\nPass ${i + 1}:`);
          let swapped = false;
          for (let j = 0; j < n - 1 - i; j++) {
            if (arr[j] > arr[j + 1]) {
              console.log(`  - swap: ${arr[j]}와(과) ${arr[j + 1]} 교환`);
              [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
              swapped = true;
              console.log(`    -> [${arr.join(", ")}]`);
            }
          }
          if (!swapped) {
            console.log(`  (교환 없음, 정렬 완료)`);
            break;
          }
          console.log(`Pass ${i + 1} 완료 후: [${arr.join(", ")}]`);
        }
        return arr;
      }

      const unsortedArray3 = [6, 1, 4, 2];
      visualBubbleSort([...unsortedArray3]);
    </script>
  </body>
</html>
