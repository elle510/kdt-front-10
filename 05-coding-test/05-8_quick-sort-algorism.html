<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>정렬 알고리즘: 퀵 정렬(Quick Sort)</title>
  </head>
  <body>
    <script>
      // 퀵 정렬(Quick Sort)은 '분할 정복(Divide and Conquer)' 전략을 사용하는
      // 매우 효율적인 정렬 알고리즘입니다.
      // 평균 시간 복잡도: O(n log n) - 매우 빠름
      // 최악 시간 복잡도: O(n^2) - 피벗 선택이 매우 편향될 경우

      // 동작 방식:
      // 1. 피벗(pivot) 선택: 배열에서 기준이 될 요소(피벗)를 하나 선택합니다.
      // 2. 분할(Partition): 피벗보다 작은 요소들은 피벗의 왼쪽, 큰 요소들은 오른쪽으로 옮깁니다.
      // 3. 정복(Conquer): 분할된 왼쪽과 오른쪽 두 개의 작은 배열에 대해 재귀적으로 퀵 정렬을 반복합니다.

      console.log("--- 퀵 정렬 ---");

      function quickSort(arr) {
        // 재귀의 탈출 조건: 배열의 길이가 1 이하면 이미 정렬된 상태
        if (arr.length <= 1) {
          return arr;
        }

        // 1. 피벗(pivot) 선택
        // 여기서는 간단하게 배열의 첫 번째 요소를 피벗으로 선택합니다.
        const pivot = arr[0];

        // 2. 분할(Partition)
        // 피벗을 제외한 나머지 요소들을 담을 두 배열을 준비합니다.
        const left = [];
        const right = [];

        for (let i = 1; i < arr.length; i++) {
          if (arr[i] < pivot) {
            // 현재 요소가 피벗보다 작으면 left 배열에 추가
            left.push(arr[i]);
          } else {
            // 현재 요소가 피벗보다 크거나 같으면 right 배열에 추가
            right.push(arr[i]);
          }
        }

        console.log(`- pivot: ${pivot}, left: [${left}], right: [${right}]`);

        // 3. 정복(Conquer) 및 조합
        // 분할된 left와 right 배열에 대해 재귀적으로 quickSort를 호출하고,
        // 그 결과와 피벗을 합쳐서 새로운 배열을 반환합니다.
        const sortedLeft = quickSort(left);
        const sortedRight = quickSort(right);

        return [...sortedLeft, pivot, ...sortedRight];
      }

      const unsortedArray = [5, 3, 8, 4, 2, 1, 9, 7, 6];
      console.log("정렬 전:", unsortedArray);
      console.log("\n정렬 과정:");
      const sortedArray = quickSort(unsortedArray);
      console.log("\n정렬 후:", sortedArray);

      /*
       * 참고:
       * 위 구현은 퀵 정렬의 핵심 아이디어를 이해하기 쉽게 작성된 버전입니다.
       * 매번 새로운 배열(left, right)을 생성하므로 메모리 사용량이 많을 수 있습니다.
       *
       * 실제로는 메모리 효율을 위해 배열을 직접 수정하는 'in-place' 방식
       * (예: Lomuto partition scheme, Hoare partition scheme)이 더 많이 사용되지만,
       * 알고리즘이 더 복잡해집니다.
       * 코딩 테스트나 학습 목적에서는 위와 같은 구현으로도 충분히 아이디어를 표현할 수 있습니다.
       */
    </script>
  </body>
</html>
