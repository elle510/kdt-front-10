<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>배열 회전시키기</title>
  </head>
  <body>
    <script>
      // 배열 nums를 오른쪽으로 k 단계만큼 회전시키는 문제입니다.
      // 예: nums = [1, 2, 3, 4, 5], k = 2  =>  [4, 5, 1, 2, 3]

      // --- 1. slice와 전개 구문을 이용한 방법 (가장 간단하고 직관적인 방법) ---
      // 배열을 두 부분으로 자른 뒤, 순서를 바꿔 다시 합치는 방식입니다.
      // 새로운 배열을 반환하며, 원본 배열을 수정하지 않습니다.
      // 시간 복잡도: O(n), 공간 복잡도: O(n)
      console.log("--- 1. slice와 전개 구문 이용 --- ");

      function rotate_slice(nums, k) {
        const n = nums.length;
        if (n === 0) return [];

        // k가 배열 길이보다 클 수 있으므로, 나머지 연산으로 실제 회전 횟수를 계산합니다.
        const effectiveK = k % n;
        if (effectiveK === 0) return [...nums]; // 회전이 필요 없는 경우

        // 배열을 자를 지점을 계산합니다.
        const splitPoint = n - effectiveK;

        // 배열을 두 부분으로 자릅니다.
        const leftPart = nums.slice(0, splitPoint);
        const rightPart = nums.slice(splitPoint);

        // 순서를 바꿔 새로운 배열을 만듭니다.
        return [...rightPart, ...leftPart];
      }

      const arr1 = [1, 2, 3, 4, 5, 6, 7];
      const k1 = 3;
      console.log(`원본: [${arr1}], k=${k1}`);
      console.log("결과:", rotate_slice(arr1, k1)); // [5, 6, 7, 1, 2, 3, 4]

      // --- 2. reverse를 이용한 방법 (In-place, 공간 효율적인 방법) ---
      // 추가 공간 없이(O(1)) 배열 자체를 수정하여 회전시키는 영리한 알고리즘입니다.
      // 1. 전체 배열을 뒤집는다.
      // 2. 앞에서부터 k개 요소를 뒤집는다.
      // 3. 나머지 n-k개 요소를 뒤집는다.
      // 시간 복잡도: O(n), 공간 복잡도: O(1)
      console.log("\n--- 2. reverse 이용 (in-place) --- ");

      // 배열의 특정 부분을 뒤집는 헬퍼 함수
      function reverse(arr, start, end) {
        while (start < end) {
          [arr[start], arr[end]] = [arr[end], arr[start]];
          start++;
          end--;
        }
      }

      function rotate_reverse(nums, k) {
        const n = nums.length;
        if (n === 0) return;
        const effectiveK = k % n;

        // 1. 전체 배열을 뒤집는다: [1,2,3,4,5,6,7] -> [7,6,5,4,3,2,1]
        reverse(nums, 0, n - 1);
        // 2. 앞에서부터 k개 요소를 뒤집는다: [7,6,5] -> [5,6,7]
        // 결과: [5,6,7,4,3,2,1]
        reverse(nums, 0, effectiveK - 1);
        // 3. 나머지 n-k개 요소를 뒤집는다: [4,3,2,1] -> [1,2,3,4]
        // 결과: [5,6,7,1,2,3,4]
        reverse(nums, effectiveK, n - 1);
      }

      const arr2 = [1, 2, 3, 4, 5, 6, 7];
      const k2 = 3;
      console.log(`원본: [${arr2}], k=${k2}`);
      rotate_reverse(arr2, k2); // arr2 자체가 변경됨
      console.log("결과:", arr2);

      // --- 3. unshift와 pop을 이용한 방법 (가장 비효율적인 방법) ---
      // k번 만큼 맨 뒤 요소를 맨 앞으로 옮기는 가장 단순한 시뮬레이션입니다.
      // unshift()가 O(n) 연산이므로, 전체 시간 복잡도는 O(n*k)가 되어 매우 느립니다.
      console.log("\n--- 3. unshift와 pop 이용 (참고용) --- ");

      function rotate_slow(nums, k) {
        const n = nums.length;
        if (n === 0) return;
        const effectiveK = k % n;

        for (let i = 0; i < effectiveK; i++) {
          // 맨 뒤 요소를 빼서 맨 앞에 추가
          nums.unshift(nums.pop());
        }
      }

      const arr3 = [1, 2, 3, 4, 5, 6, 7];
      const k3 = 3;
      console.log(`원본: [${arr3}], k=${k3}`);
      rotate_slow(arr3, k3);
      console.log("결과:", arr3);
    </script>
  </body>
</html>
