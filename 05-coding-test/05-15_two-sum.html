<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>두 수의 합(Two Sum) 인덱스 찾기</title>
  </head>
  <body>
    <script>
      // "두 수의 합(Two Sum)" 문제는 숫자 배열(nums)과 목표값(target)이 주어졌을 때,
      // 배열의 두 숫자를 더해 목표값을 만들 수 있는 두 숫자의 인덱스를 찾는 문제입니다.
      // 예: nums = [2, 7, 11, 15], target = 9  =>  결과: [0, 1] (nums[0] + nums[1] = 2 + 7 = 9)

      // --- 1. 이중 반복문(Brute Force)을 이용한 방법 ---
      // 가장 직관적인 방법으로, 모든 가능한 두 수의 조합을 확인합니다.
      // 시간 복잡도: O(n^2) - 배열이 클 경우 매우 비효율적입니다.
      console.log("--- 1. 이중 반복문 방식 ---");

      function twoSum_bruteForce(nums, target) {
        const n = nums.length;
        // 첫 번째 숫자를 선택하는 외부 루프
        for (let i = 0; i < n - 1; i++) {
          // 두 번째 숫자를 선택하는 내부 루프
          // j = i + 1 부터 시작하여 같은 요소를 두 번 사용하지 않고, 중복 검사를 피합니다.
          for (let j = i + 1; j < n; j++) {
            // 두 수의 합이 target과 같은지 확인
            if (nums[i] + nums[j] === target) {
              return [i, j];
            }
          }
        }
        // 모든 조합을 확인했지만 답을 찾지 못한 경우
        return "답을 찾을 수 없습니다.";
      }

      const nums1 = [2, 7, 11, 15];
      const target1 = 9;
      console.log(
        `[${nums1}]에서 합이 ${target1}이 되는 인덱스:`,
        twoSum_bruteForce(nums1, target1)
      ); // [0, 1]

      // --- 2. 해시 맵(Hash Map)을 이용한 방법 (최적화된 방법) ---
      // 한 번의 순회로 문제를 해결하는 효율적인 방법입니다. 코딩 인터뷰에서 기대하는 정답입니다.
      // 시간 복잡도: O(n) - 매우 빠름
      // 공간 복잡도: O(n) - 맵에 데이터를 저장하기 위한 추가 공간 필요
      console.log("\n--- 2. 해시 맵 방식 (최적화) ---");

      function twoSum_map(nums, target) {
        // 숫자의 값과 인덱스를 저장할 맵(객체) 생성
        const numMap = {}; // { '숫자': 인덱스 }

        for (let i = 0; i < nums.length; i++) {
          const currentNum = nums[i];
          // 현재 필요한 짝(complement)을 계산: target - 현재 숫자
          const complement = target - currentNum;

          // 맵에 필요한 짝이 이미 존재하는지 확인
          if (complement in numMap) {
            // 존재한다면, 필요한 짝의 인덱스와 현재 인덱스를 반환
            return [numMap[complement], i];
          }

          // 맵에 필요한 짝이 없다면, 현재 숫자와 인덱스를 맵에 기록
          // (다음 순회에서 이 숫자가 다른 숫자의 짝이 될 수 있도록)
          numMap[currentNum] = i;
        }

        return "답을 찾을 수 없습니다.";
      }

      const nums2 = [3, 2, 4];
      const target2 = 6;
      console.log(
        `[${nums2}]에서 합이 ${target2}가 되는 인덱스:`,
        twoSum_map(nums2, target2)
      ); // [1, 2]

      const nums3 = [3, 3];
      const target3 = 6;
      console.log(
        `[${nums3}]에서 합이 ${target3}이 되는 인덱스:`,
        twoSum_map(nums3, target3)
      ); // [0, 1]
    </script>
  </body>
</html>
