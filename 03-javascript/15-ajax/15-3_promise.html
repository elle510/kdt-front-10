<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Promise 이해하기</title>
    <style>
      body {
        font-family: sans-serif;
        line-height: 1.6;
      }
      .container {
        border: 1px solid #ccc;
        padding: 10px;
        margin-bottom: 20px;
      }
      pre {
        background-color: #f4f4f4;
        padding: 10px;
        border-radius: 5px;
      }
    </style>
  </head>
  <body>
    <h1>JavaScript Promise</h1>
    <p>
      브라우저의 개발자 도구(F12) 콘솔을 열어 비동기 실행 흐름을 확인하세요.
    </p>

    <div class="container">
      <h2>Promise 기본 예제</h2>
      <p>버튼을 누르면 1.5초 후에 성공 또는 실패하는 Promise를 실행합니다.</p>
      <button id="successBtn">성공하는 Promise 실행</button>
      <button id="failBtn">실패하는 Promise 실행</button>
      <pre id="output"></pre>
    </div>

    <script>
      const successBtn = document.getElementById("successBtn");
      const failBtn = document.getElementById("failBtn");
      const output = document.getElementById("output");

      /**
       * Promise는 비동기 작업의 최종 완료 또는 실패를 나타내는 객체입니다.
       * 세 가지 상태를 가집니다:
       * 1. pending: 초기 상태, 이행하거나 거부되지 않음.
       * 2. fulfilled: 작업이 성공적으로 완료됨. (resolve 함수 호출)
       * 3. rejected: 작업이 실패함. (reject 함수 호출)
       */

      // Promise를 생성하는 함수
      function createPromise(shouldSucceed) {
        // new Promise()는 비동기 작업을 수행하는 실행자(executor) 함수를 인자로 받습니다.
        // 이 실행자 함수는 resolve와 reject라는 두 개의 함수를 인자로 받습니다.
        return new Promise((resolve, reject) => {
          output.textContent = "Promise가 생성되었습니다. (pending 상태)";
          console.log("Promise가 생성되었습니다. (pending 상태)");

          setTimeout(() => {
            if (shouldSucceed) {
              // 작업이 성공하면 resolve()를 호출하여 결과를 전달합니다.
              // Promise는 fulfilled 상태가 됩니다.
              resolve("작업 성공! 데이터 여기 있습니다.");
            } else {
              // 작업이 실패하면 reject()를 호출하여 에러(이유)를 전달합니다.
              // Promise는 rejected 상태가 됩니다.
              reject("작업 실패... 문제가 발생했습니다.");
            }
          }, 1500); // 1.5초의 비동기 작업을 시뮬레이션
        });
      }

      // --- Promise 사용하기 ---

      successBtn.addEventListener("click", () => {
        const myPromise = createPromise(true);

        myPromise
          .then((successMessage) => {
            // .then()은 Promise가 fulfilled 상태가 되었을 때 실행됩니다.
            // resolve()가 전달한 값을 인자로 받습니다.
            const message = `[성공] ${successMessage}`;
            console.log(message);
            output.textContent = message;
          })
          .catch((errorMessage) => {
            // .catch()는 Promise가 rejected 상태가 되었을 때 실행됩니다.
            // 이 경우에는 호출되지 않습니다.
            const message = `[실패] ${errorMessage}`;
            console.error(message);
            output.textContent = message;
          })
          .finally(() => {
            // .finally()는 Promise의 성공/실패 여부와 상관없이 항상 마지막에 실행됩니다.
            console.log("Promise 작업이 종료되었습니다.");
          });
      });

      failBtn.addEventListener("click", () => {
        const myPromise = createPromise(false);

        myPromise
          .then((successMessage) => {
            // 이 경우에는 호출되지 않습니다.
            const message = `[성공] ${successMessage}`;
            console.log(message);
            output.textContent = message;
          })
          .catch((errorMessage) => {
            // .catch()는 Promise가 rejected 상태가 되었을 때 실행됩니다.
            // reject()가 전달한 값을 인자로 받습니다.
            const message = `[실패] ${errorMessage}`;
            console.error(message);
            output.textContent = message;
          })
          .finally(() => {
            // .finally()는 Promise의 성공/실패 여부와 상관없이 항상 마지막에 실행됩니다.
            console.log("Promise 작업이 종료되었습니다.");
          });
      });

      // --- Promise Chaining 예제 ---
      console.log("--- Promise Chaining 예제 ---");
      new Promise((resolve, reject) => {
        setTimeout(() => resolve(10), 500);
      })
        .then((result) => {
          console.log("첫 번째 then:", result); // 10
          // 이전 then에서 값을 반환하면, 다음 then으로 전달됩니다.
          return result * 2;
        })
        .then((result) => {
          console.log("두 번째 then:", result); // 20
          return result + 30;
        })
        .then((result) => {
          console.log("세 번째 then:", result); // 50
        })
        .catch((error) => {
          console.error("체이닝 중 에러 발생:", error);
        });
    </script>
  </body>
</html>
