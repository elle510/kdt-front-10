<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>메모리 누수 방지</title>
    <style>
      body {
        font-family: sans-serif;
        line-height: 1.6;
        padding: 20px;
      }
      .container {
        border: 1px solid #ccc;
        padding: 10px;
        margin-bottom: 20px;
      }
      pre {
        background-color: #f4f4f4;
        padding: 10px;
        border-radius: 5px;
      }
      button {
        margin-right: 10px;
      }
    </style>
  </head>
  <body>
    <h1>JavaScript 메모리 누수 방지</h1>
    <p>브라우저의 개발자 도구(F12) 콘솔과 페이지의 로그를 확인하세요.</p>

    <div class="container">
      <h2>1. 이벤트 리스너 해제 (메모리 누수 방지)</h2>
      <p>
        컴포넌트가 더 이상 필요 없을 때, 등록했던 이벤트 리스너를 제거하지
        않으면 메모리 누수가 발생합니다.
      </p>
      <button id="createBtn">컴포넌트 생성</button>
      <button id="destroyBtn">컴포넌트 제거</button>
      <button id="createLeakyBtn">[누수 예시] 컴포넌트 생성</button>
      <button id="destroyLeakyBtn">[누수 예시] 컴포넌트 제거</button>
      <pre id="log"></pre>
    </div>

    <div class="container">
      <h2>2. WeakMap을 사용한 데이터 캐싱</h2>
      <p>
        <code>Map</code>은 키(객체)에 대한 강력한 참조를 유지하여 가비지
        컬렉션을 방해할 수 있지만, <code>WeakMap</code>은 그렇지 않아 메모리
        누수 방지에 유리합니다.
      </p>
    </div>

    <script>
      const logDiv = document.getElementById("log");
      function log(message) {
        console.log(message);
        logDiv.textContent = message;
      }

      // --- 1. 이벤트 리스너 해제 예제 ---
      let component = null;
      let leakyComponent = null;

      // 올바른 예시
      class Component {
        constructor() {
          log(
            "✅ 올바른 컴포넌트가 생성되었습니다. 이제 페이지를 클릭해 보세요."
          );
          // this 컨텍스트를 유지하기 위해 handleClick을 바인딩합니다.
          this.handleClick = this.handleClick.bind(this);
          // document와 같은 전역 객체에 이벤트 리스너를 등록합니다.
          document.addEventListener("click", this.handleClick);
        }

        handleClick(event) {
          // 버튼 클릭은 무시
          if (event.target.tagName === "BUTTON") return;
          log("✅ (올바른 컴포넌트) 페이지 클릭됨!");
        }

        destroy() {
          log("✅ 이벤트 리스너를 제거하여 메모리 누수를 방지합니다.");
          // destroy 시점에 등록했던 이벤트 리스너를 반드시 제거해야 합니다.
          document.removeEventListener("click", this.handleClick);
        }
      }

      // 메모리 누수 예시
      class LeakyComponent {
        constructor() {
          log("❌ 누수 컴포넌트가 생성되었습니다.");
          this.handleClick = this.handleClick.bind(this);
          document.addEventListener("click", this.handleClick);
        }

        handleClick(event) {
          if (event.target.tagName === "BUTTON") return;
          log(
            "❌ (누수 컴포넌트) 페이지 클릭됨! 이 메시지는 컴포넌트 제거 후에도 나타납니다."
          );
        }

        destroy() {
          log("❌ 이벤트 리스너를 제거하지 않았습니다.");
          // removeEventListener 코드가 없음
        }
      }

      document.getElementById("createBtn").onclick = () => {
        if (!component) component = new Component();
      };
      document.getElementById("destroyBtn").onclick = () => {
        if (component) {
          component.destroy();
          component = null; // 가비지 컬렉션 대상이 되도록 참조를 제거
        }
      };
      document.getElementById("createLeakyBtn").onclick = () => {
        if (!leakyComponent) leakyComponent = new LeakyComponent();
      };
      document.getElementById("destroyLeakyBtn").onclick = () => {
        if (leakyComponent) {
          leakyComponent.destroy();
          leakyComponent = null;
        }
      };

      // --- 2. WeakMap 예제 (개념 설명) ---
      console.group("Map vs WeakMap");

      // Map: 강력한 참조
      let map = new Map();
      let obj = { id: 1 }; // 객체 생성
      map.set(obj, "some data"); // Map에 객체를 키로 데이터 저장
      console.log("Map 사이즈:", map.size); // 1

      // 이제 obj에 대한 참조를 제거
      obj = null;

      // obj를 null로 만들어도, Map이 여전히 obj에 대한 참조를 가지고 있기 때문에
      // 가비지 컬렉터(GC)는 obj를 메모리에서 제거할 수 없습니다. 이것이 메모리 누수로 이어질 수 있습니다.
      console.log("obj를 null로 만든 후 Map 사이즈:", map.size); // 여전히 1
      console.log(
        "Map이 참조를 유지하여 객체가 메모리에 남아있음.",
        map.keys().next().value
      );

      // WeakMap: 약한 참조
      let weakMap = new WeakMap();
      let weakObj = { id: 2 }; // 객체 생성
      weakMap.set(weakObj, "some other data"); // WeakMap에 객체를 키로 데이터 저장

      // 이제 weakObj에 대한 참조를 제거
      weakObj = null;

      // weakObj를 null로 만들면, 이 객체에 대한 다른 참조가 없으므로
      // 가비지 컬렉터(GC)는 weakObj를 메모리에서 제거할 수 있습니다.
      // GC가 동작하면, WeakMap의 해당 엔트리도 자동으로 사라집니다.
      // (참고: GC 동작은 예측할 수 없으며, 코드로 직접 확인은 어려움)
      console.log(
        "weakObj를 null로 만든 후, GC가 동작하면 WeakMap의 항목은 자동으로 제거됩니다."
      );

      console.groupEnd();
    </script>
  </body>
</html>
