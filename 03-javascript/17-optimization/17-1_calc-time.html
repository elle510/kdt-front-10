<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>코드 실행 시간 최적화</title>
    <style>
      body {
        font-family: sans-serif;
        line-height: 1.6;
      }
      .container {
        border: 1px solid #ccc;
        padding: 10px;
        margin-bottom: 20px;
      }
      pre {
        background-color: #f4f4f4;
        padding: 10px;
        border-radius: 5px;
      }
      button {
        padding: 10px 15px;
        font-size: 16px;
      }
    </style>
  </head>
  <body>
    <h1>알고리즘 개선을 통한 실행 시간 최적화</h1>
    <p>배열에서 중복된 항목을 찾는 두 가지 방법의 성능을 비교합니다.</p>
    <p>
      버튼을 누르면 약 50,000개의 항목을 가진 배열을 생성하여 테스트를
      시작합니다. 브라우저의 개발자 도구(F12) 콘솔에서 실행 시간을 확인하세요.
    </p>

    <button id="runTestBtn">성능 테스트 시작</button>

    <div class="container">
      <h2>O(n²) - 비효율적인 방법 (중첩 루프)</h2>
      <pre id="inefficient-result"></pre>
    </div>

    <div class="container">
      <h2>O(n) - 효율적인 방법 (Set 활용)</h2>
      <pre id="efficient-result"></pre>
    </div>

    <script>
      // 비효율적인 방법 - O(n²)
      function findDuplicates(arr) {
        const duplicates = [];
        for (let i = 0; i < arr.length; i++) {
          for (let j = i + 1; j < arr.length; j++) {
            // arr.includes() 또한 내부적으로 루프를 돌기 때문에 실제 성능은 더 나쁩니다.
            if (arr[i] === arr[j] && !duplicates.includes(arr[i])) {
              duplicates.push(arr[i]);
            }
          }
        }
        return duplicates;
      }

      // 효율적인 방법 - O(n)
      function findDuplicatesOptimized(arr) {
        const seen = new Set();
        const duplicates = new Set();

        for (const item of arr) {
          // Set.has()는 평균적으로 O(1)의 시간 복잡도를 가집니다.
          if (seen.has(item)) {
            duplicates.add(item);
          } else {
            seen.add(item);
          }
        }

        return Array.from(duplicates);
      }

      document.getElementById("runTestBtn").addEventListener("click", () => {
        // --- 테스트 데이터 생성 ---
        const largeArray = [];
        const arraySize = 50000;
        for (let i = 0; i < arraySize; i++) {
          // 0부터 20000 사이의 난수를 추가하여 중복을 유도
          largeArray.push(Math.floor(Math.random() * 20000));
        }
        console.log(`${arraySize}개의 항목을 가진 테스트 배열 생성 완료`);

        // --- 비효율적인 방법 테스트 ---
        const inefficientOutput = document.getElementById("inefficient-result");
        inefficientOutput.textContent =
          "계산 중... (시간이 오래 걸릴 수 있습니다)";
        // setTimeout을 사용하여 UI 렌더링 후 계산 시작
        setTimeout(() => {
          console.time("O(n²) 실행 시간");
          const result1 = findDuplicates(largeArray);
          console.timeEnd("O(n²) 실행 시간");
          inefficientOutput.textContent = `찾은 중복 항목 수: ${result1.length}\n(자세한 시간은 콘솔을 확인하세요)`;
          console.log("O(n²) 결과:", result1);
        }, 50);

        // --- 효율적인 방법 테스트 ---
        const efficientOutput = document.getElementById("efficient-result");
        efficientOutput.textContent = "계산 중...";
        setTimeout(() => {
          console.time("O(n) 실행 시간");
          const result2 = findDuplicatesOptimized(largeArray);
          console.timeEnd("O(n) 실행 시간");
          efficientOutput.textContent = `찾은 중복 항목 수: ${result2.length}\n(자세한 시간은 콘솔을 확인하세요)`;
          console.log("O(n) 결과:", result2);
        }, 50);
      });

      /**
       * 왜 성능 차이가 발생할까요?
       *
       * 1. 비효율적인 방법 (O(n²)):
       *    배열의 모든 항목을 다른 모든 항목과 비교합니다 (중첩 for 루프).
       *    50,000개 항목 배열의 경우, 약 50000 * 50000 = 25억 번의 비교가 필요합니다.
       *    게다가 duplicates.includes() 호출도 배열을 순회하므로 성능이 더욱 저하됩니다.
       *
       * 2. 효율적인 방법 (O(n)):
       *    배열을 단 한 번만 순회합니다.
       *    Set 자료구조를 사용하여 특정 항목이 이미 등장했는지 확인(seen.has())하는 데에는
       *    평균적으로 O(1)의 시간이 걸립니다. 이는 매우 빠른 연산입니다.
       *    따라서 전체 작업은 약 50,000번의 연산으로 완료됩니다.
       *
       * 결과적으로, 데이터의 양이 커질수록 두 알고리즘의 성능 차이는 기하급수적으로 벌어집니다.
       */
    </script>
  </body>
</html>
