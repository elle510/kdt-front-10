<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>DOM 조작 최적화</title>
    <style>
      body {
        font-family: sans-serif;
        line-height: 1.6;
      }
      .container {
        border: 1px solid #ccc;
        padding: 10px;
        margin-bottom: 20px;
        width: 45%;
        float: left;
        margin-right: 2%;
      }
      ul {
        height: 200px;
        overflow-y: scroll;
        border: 1px solid #eee;
        padding: 5px;
      }
      button {
        padding: 10px 15px;
        margin-bottom: 10px;
      }
      pre {
        background-color: #f4f4f4;
        padding: 10px;
        border-radius: 5px;
        font-size: 14px;
      }
    </style>
  </head>
  <body>
    <h1>DOM 조작 최적화 (Reflow/Repaint)</h1>
    <p>
      많은 수의 DOM 요소를 추가할 때, 두 가지 방법의 성능을 비교합니다.
      (10,000개 아이템 추가)
    </p>
    <p>브라우저의 개발자 도구(F12) 콘솔에서 실행 시간을 확인하세요.</p>

    <div class="container">
      <h2>비효율적인 방법</h2>
      <button id="run-inefficient">실행</button>
      <pre id="inefficient-time"></pre>
      <ul id="list-inefficient"></ul>
    </div>

    <div class="container">
      <h2>효율적인 방법 (DocumentFragment)</h2>
      <button id="run-efficient">실행</button>
      <pre id="efficient-time"></pre>
      <ul id="list-efficient"></ul>
    </div>

    <script>
      const inefficientBtn = document.getElementById("run-inefficient");
      const efficientBtn = document.getElementById("run-efficient");
      const inefficientTime = document.getElementById("inefficient-time");
      const efficientTime = document.getElementById("efficient-time");

      const itemsToAdd = [];
      const itemCount = 10000;
      for (let i = 0; i < itemCount; i++) {
        itemsToAdd.push(`아이템 ${i + 1}`);
      }

      // 비효율적인 DOM 조작
      function addItems(items) {
        const list = document.getElementById("list-inefficient");
        list.innerHTML = ""; // 리스트 초기화
        console.time("비효율적 DOM 조작 시간");
        items.forEach((item) => {
          const li = document.createElement("li");
          li.textContent = item;
          // 반복문 안에서 DOM에 직접 요소를 추가합니다.
          // 이 코드가 실행될 때마다 브라우저는 리플로우(Reflow)와 리페인트(Repaint)를 유발할 수 있습니다.
          list.appendChild(li);
          // // DOM을 변경한 후, 레이아웃 정보를 읽어 강제로 리플로우를 유발
          // const a = list.offsetHeight;
        });
        const time = console.timeEnd("비효율적 DOM 조작 시간");
        inefficientTime.textContent = `실행 시간은 콘솔을 확인하세요.`;
      }

      // 효율적인 DOM 조작
      function addItemsOptimized(items) {
        const list = document.getElementById("list-efficient");
        list.innerHTML = ""; // 리스트 초기화
        console.time("효율적 DOM 조작 시간");
        // DocumentFragment는 메모리에만 존재하는 가상의 DOM 컨테이너입니다.
        const fragment = document.createDocumentFragment();
        items.forEach((item) => {
          const li = document.createElement("li");
          li.textContent = item;
          // 실제 DOM이 아닌 메모리상의 fragment에 요소를 추가합니다.
          // 이 과정에서는 리플로우/리페인트가 발생하지 않습니다.
          fragment.appendChild(li);
        });
        // 모든 요소가 준비된 fragment를 실제 DOM에 단 한 번만 추가합니다.
        // 리플로우와 리페인트가 여기서 딱 한 번만 발생합니다.
        list.appendChild(fragment);
        const time = console.timeEnd("효율적 DOM 조작 시간");
        efficientTime.textContent = `실행 시간은 콘솔을 확인하세요.`;
      }

      inefficientBtn.addEventListener("click", () => addItems(itemsToAdd));
      efficientBtn.addEventListener("click", () =>
        addItemsOptimized(itemsToAdd)
      );

      /**
       * 왜 성능 차이가 발생할까요?
       *
       * 브라우저 렌더링 과정:
       * - 리플로우(Reflow/Layout): 요소의 크기나 위치 등 레이아웃에 영향을 주는 변경이 발생했을 때, 렌더 트리를 재구성하는 과정.
       * - 리페인트(Repaint): 리플로우 후, 변경된 부분을 화면에 다시 그리는 과정. 리플로우는 비용이 매우 큰 작업입니다.
       *
       * 1. 비효율적인 방법:
       *    `list.appendChild(li)`가 루프 안에서 10,000번 호출됩니다. 최악의 경우, 브라우저는 이 때마다
       *    리스트의 레이아웃을 다시 계산(리플로우)하고 화면을 다시 그려야(리페인트) 합니다.
       *    이는 엄청난 부하를 유발하여 페이지가 버벅이거나 멈추게 할 수 있습니다.
       *
       * 2. 효율적인 방법 (DocumentFragment):
       *    `DocumentFragment`는 실제 DOM 트리의 일부가 아닌, 메모리에 존재하는 가벼운 컨테이너입니다.
       *    모든 `li` 요소들을 이 가상의 컨테이너에 먼저 추가합니다. 이 과정은 DOM에 영향을 주지 않으므로 리플로우가 발생하지 않습니다.
       *    모든 `li`가 준비되면, `fragment` 자체를 실제 DOM에 단 한 번만 추가합니다.
       *    따라서 리플로우와 리페인트가 딱 한 번만 발생하여 성능이 크게 향상됩니다.
       */
      /*
      최신 브라우저(Chrome, Firefox 등)의 JavaScript 엔진과 렌더링 엔진은 매우 똑똑해졌습니다. 개발자가 비효율적인 코드를
      작성하더라도, 엔진이 이를 감지하고 자체적으로 최적화를 수행하는 경우가 많습니다.

      현재 예제의 경우, 짧은 시간 안에 동일한 부모에게 appendChild가 반복적으로 일어나는 것을 브라우저가 감지하고, 실제 
      리플로우(Reflow)를 한 번에 처리하도록 변경 사항을 자동으로 묶어서(batch) 처리합니다.

      따라서 DocumentFragment를 사용하는 것과 거의 동일한 효과가 나게 되고, 오히려 DocumentFragment 객체를 생성하고 관리하는 약간의
      오버헤드 때문에 비효율적인 코드의 JavaScript 실행 시간(console.time으로 측정된 시간)이 더 짧게 보일 수 있는 것입니다.

      그럼에도 DocumentFragment가 권장되는 이유

        1. 보장된 성능: DocumentFragment를 사용하는 것은 개발자가 브라우저에게 "나는 DOM 변경을 한 번만 할 것이니, 리플로우도 한 번만
            해줘"라고 명시적으로 의도를 전달하는 것입니다. 이는 모든 브라우저에서 예측 가능하고 일관된 성능을 보장합니다.
        2. 최적화의 한계: 브라우저의 자동 최적화는 항상 동작하는 것이 아닙니다. 만약 루프 안에서 DOM의 크기나 위치를 읽는 코드(예:
            element.offsetHeight)가 단 한 줄이라도 추가되면, 브라우저는 정확한 값을 계산하기 위해 최적화를 포기하고 즉시 리플로우를
            실행해야 합니다. 이런 현상을 '강제 동기 레이아웃(Forced Synchronous Layout)' 또는 '레이아웃 스래싱(Layout Thrashing)'이라고
            부르며, 성능을 급격히 저하시킵니다.
      */
    </script>
  </body>
</html>
