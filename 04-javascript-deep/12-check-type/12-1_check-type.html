<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>JavaScript 타입 체크</title>
  </head>
  <body>
    <script>
      // JavaScript는 동적 타입 언어이므로, 코드 실행 중에 변수의 타입을 확인해야 할 때가 많습니다.
      // 타입을 확인하는 몇 가지 방법을 알아봅니다.

      const str = "hello";
      const num = 123;
      const bool = true;
      const undef = undefined;
      const nul = null;
      const arr = [];
      const obj = {};
      const fn = function () {};
      const date = new Date();

      // ------------------- 1. typeof 연산자 -------------------
      // 가장 간단하지만, 몇 가지 함정이 있습니다.
      console.log("--- 1. typeof ---");
      console.log("typeof str:", typeof str); // "string"
      console.log("typeof num:", typeof num); // "number"
      console.log("typeof bool:", typeof bool); // "boolean"
      console.log("typeof undef:", typeof undef); // "undefined"
      console.log("typeof fn:", typeof fn); // "function"

      // --- typeof의 함정 ---
      // 1. null을 object로 반환합니다. (JavaScript 초기 버전의 버그)
      console.log("typeof nul:", typeof nul); // "object"
      // 2. 배열(Array)을 object로 반환합니다.
      console.log("typeof arr:", typeof arr); // "object"
      // 3. Date 객체 등도 object로 반환합니다.
      console.log("typeof date:", typeof date); // "object"
      // => typeof는 원시 타입(primitive)과 함수를 구분하는 데는 유용하지만, null과 객체 타입을 세분화하지 못합니다.

      // ------------------- 2. instanceof 연산자 -------------------
      // 객체가 특정 클래스(생성자)의 인스턴스인지 확인합니다. 프로토타입 체인을 확인합니다.
      console.log("\n--- 2. instanceof ---");
      console.log("arr instanceof Array:", arr instanceof Array); // true
      console.log("obj instanceof Object:", obj instanceof Object); // true
      console.log("date instanceof Date:", date instanceof Date); // true
      console.log("date instanceof Object:", date instanceof Object); // true (Date는 Object를 상속받음)

      // --- instanceof의 한계 ---
      // 원시 타입에는 사용할 수 없습니다.
      console.log("str instanceof String:", str instanceof String); // false

      // ------------------- 3. Array.isArray() (ES5+) -------------------
      // 배열 타입을 확인하는 가장 안정적이고 권장되는 방법입니다.
      console.log("\n--- 3. Array.isArray() ---");
      console.log("Array.isArray(arr):", Array.isArray(arr)); // true
      console.log("Array.isArray(obj):", Array.isArray(obj)); // false

      // ------------------- 4. Object.prototype.toString.call() -------------------
      // 모든 타입을 가장 정확하고 안정적으로 판별할 수 있는 방법입니다.
      console.log("\n--- 4. Object.prototype.toString.call() ---");
      console.log("toString.call(str):", Object.prototype.toString.call(str)); // "[object String]"
      console.log("toString.call(num):", Object.prototype.toString.call(num)); // "[object Number]"
      console.log("toString.call(nul):", Object.prototype.toString.call(nul)); // "[object Null]" (typeof와 달리 정확함)
      console.log("toString.call(arr):", Object.prototype.toString.call(arr)); // "[object Array]" (typeof와 달리 정확함)
      console.log("toString.call(obj):", Object.prototype.toString.call(obj)); // "[object Object]"
      console.log("toString.call(date):", Object.prototype.toString.call(date)); // "[object Date]"

      // 사용하기 편하게 함수로 만들어 활용할 수 있습니다.
      function getType(target) {
        return Object.prototype.toString.call(target).slice(8, -1);
      }
      console.log("getType(nul):", getType(nul)); // "Null"
      console.log("getType(arr):", getType(arr)); // "Array"
      console.log("getType(date):", getType(date)); // "Date"

      // ------------------- 5. 결론 및 추천 방법 -------------------
      /*
       * - 원시 타입 (string, number, boolean, undefined, symbol) 확인: `typeof`
       * - 배열(Array) 확인: `Array.isArray()`
       * - 특정 객체 인스턴스 확인: `instanceof`
       * - null, 배열, 객체 등을 포함한 모든 타입을 명확히 구분해야 할 때: `Object.prototype.toString.call()`
       */
    </script>
  </body>
</html>
