<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>배열 정렬 시 불변성 유지하기</title>
  </head>
  <body>
    <script>
      // 배열을 정렬할 때 원본을 수정하는 것은 예기치 않은 부수 효과(side effect)를
      // 일으킬 수 있어, 특히 함수형 프로그래밍이나 React 같은 상태 관리 라이브러리에서 중요하게 다뤄집니다.
      // 이를 "불변성을 지키지 못했다"라고 합니다.

      // ------------------- 문제 상황: 원본 배열이 변경됨 -------------------
      console.log("--- 문제 상황 ---");
      let originalArray_problem = [3, 1, 4, 1, 5, 9];
      console.log("정렬 전 원본 배열:", originalArray_problem);

      // .sort() 메서드는 원본 배열을 직접 수정합니다.
      let sortedArray_problem = originalArray_problem.sort();

      console.log("정렬 후 원본 배열:", originalArray_problem); // [1, 1, 3, 4, 5, 9] -> 원본이 변경됨!
      console.log("정렬된 배열:", sortedArray_problem);
      console.log(
        "두 배열은 같은가?",
        originalArray_problem === sortedArray_problem
      ); // true, 같은 배열을 가리킴

      // ------------------- 해결 방법 1: 전개 구문(...)으로 배열 복사 (ES6+, 추천) -------------------
      console.log("\n--- 해결 1: 전개 구문(...) ---");
      let originalArray1 = [3, 1, 4, 1, 5, 9];
      console.log("정렬 전 원본 배열:", originalArray1);

      // 1. 전개 구문(...)을 사용해 배열의 얕은 복사본을 만든다.
      // 2. 복사본에 대해 .sort()를 실행한다.
      const newSortedArray1 = [...originalArray1].sort((a, b) => a - b);

      console.log("정렬 후 원본 배열:", originalArray1); // [3, 1, 4, 1, 5, 9] -> 원본 유지!
      console.log("새로 정렬된 배열:", newSortedArray1); // [1, 3, 4, 5, 9]
      console.log("두 배열은 같은가?", originalArray1 === newSortedArray1); // false, 다른 배열임

      // ------------------- 해결 방법 2: slice() 메서드로 배열 복사 -------------------
      console.log("\n--- 해결 2: slice() ---");
      let originalArray2 = [3, 1, 4, 1, 5, 9];
      console.log("정렬 전 원본 배열:", originalArray2);

      // .slice()는 배열의 일부 또는 전체를 복사한 새로운 배열을 반환합니다.
      const newSortedArray2 = originalArray2.slice().sort((a, b) => a - b);

      console.log("정렬 후 원본 배열:", originalArray2); // [3, 1, 4, 1, 5, 9] -> 원본 유지!
      console.log("새로 정렬된 배열:", newSortedArray2);

      // ------------------- 해결 방법 3: Array.from() 메서드 -------------------

      console.log("\n--- 해결 3: Array.from() ---");

      let originalArray4 = [3, 1, 4, 1, 5, 9];

      console.log("정렬 전 원본 배열:", originalArray4);

      // Array.from()은 배열 또는 유사 배열 객체를 복사해 새로운 배열을 만듭니다.

      const newSortedArray4 = Array.from(originalArray4).sort((a, b) => a - b);

      console.log("정렬 후 원본 배열:", originalArray4); // 원본 유지!

      console.log("새로 정렬된 배열:", newSortedArray4);

      // ------------------- 해결 방법 4: concat() 메서드 -------------------

      console.log("\n--- 해결 4: concat() ---");

      let originalArray5 = [3, 1, 4, 1, 5, 9];

      console.log("정렬 전 원본 배열:", originalArray5);

      // 빈 배열에 원본 배열을 concat하거나, 원본 배열에 빈 concat을 실행해도 복사본이 만들어집니다.

      const newSortedArray5 = originalArray5.concat().sort((a, b) => a - b);

      console.log("정렬 후 원본 배열:", originalArray5); // 원본 유지!

      console.log("새로 정렬된 배열:", newSortedArray5);

      // ------------------- 해결 방법 5: toSorted() 메서드 (ES2023, 최신) -------------------
      console.log("\n--- 해결 5: toSorted() ---");
      let originalArray3 = [3, 1, 4, 1, 5, 9];
      console.log("정렬 전 원본 배열:", originalArray3);

      // .toSorted()는 원본을 변경하지 않고 정렬된 새 배열을 반환하는 최신 메서드입니다.
      // (참고: 일부 구형 브라우저에서는 지원되지 않을 수 있습니다.)
      const newSortedArray3 = originalArray3.toSorted((a, b) => a - b);

      console.log("정렬 후 원본 배열:", originalArray3); // [3, 1, 4, 1, 5, 9] -> 원본 유지!

      console.log("새로 정렬된 배열:", newSortedArray3);
    </script>
  </body>
</html>
